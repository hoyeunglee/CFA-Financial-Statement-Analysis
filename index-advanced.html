<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EDGAR Financial Statement Viewer + CFA Valuation</title>
  <script src="./xlsx.full.min.js"></script>
  <style>
    body { font-family: Arial; padding: 20px; }
    input, button { padding: 8px; margin: 5px; }
    table { border-collapse: collapse; margin-top: 20px; width: 100%; }
    th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
    th { background: #f0f0f0; }
    .section-title { margin-top: 40px; font-weight: bold; }
    pre, #valuationOutput { background: #f9f9f9; padding: 10px; border: 1px solid #ccc; white-space: pre-wrap; }
    #statementItemList { max-height: 400px; overflow-y: auto; font-family: monospace; }
    .warn { color: #b91c1c; }
    .ok { color: #14532d; }
  </style>
</head>
<body>

  <h2>EDGAR Financial Statement Viewer + CFA Valuation, npm proxy/server.js</h2>

  <input type="text" id="ticker" placeholder="Enter stock ticker (e.g., AAPL)" />
  <button onclick="fetchFinancials()">Fetch Financials</button>
  <button onclick="downloadCSV()">Export CSV</button>
  <button onclick="calculateRatios()">Evaluate Basic Ratios</button>
  <button onclick="calculateDetailedRatios()">Calculate Detailed Ratios</button>
  <button onclick="performEquityValuation()">Equity Valuation (Simple DDM)</button>
  <button onclick="runAdvancedValuation()">Run Advanced CFA Valuation</button>
  <button onclick="runSubramanyamFSA()">Advanced FSA Valuation (Subramanyam)</button>
  <button onclick="showCompanyDetails()">Show Company Details</button>
  <button onclick="showLatestDividend()">Show Latest Dividend Info</button>
  <button onclick="showAllStatementItems()">Show All Statement Items</button>
  <button onclick="showStandardXBRLItems()">Show Standard XBRL Items</button>

  <div id="status"></div>

  <div class="section-title">Balance Sheet</div>
  <table id="balanceSheetTable"></table>

  <div class="section-title">Profit & Loss Statement</div>
  <table id="plTable"></table>

  <div class="section-title">Financial Ratios</div>
  <table id="ratiosTable"></table>

  <div class="section-title">Equity Valuation (CFA Style)</div>
  <pre id="valuationOutput"></pre>

  <div class="section-title">Company Details</div>
  <pre id="companyDetails"></pre>

  <div class="section-title">Latest Dividend Info</div>
  <pre id="dividendInfo"></pre>

<script>
  let balanceData = [];
  let plData = [];
  let ratioData = [];
  let currentCIK = "";
  let submissionsData = null;

  // Store collected financial data for valuation
  let financialsForValuation = {};

  async function fetchCIK(ticker) {
    const res = await fetch('/api/tickers');
    const json = await res.json();
    for (const key in json) {
      if (json[key].ticker.toUpperCase() === ticker.toUpperCase()) {
        return json[key].cik_str.toString().padStart(10, '0');
      }
    }
    throw new Error("CIK not found");
  }

  async function fetchSubmissions(cik) {
    const url = `/api/submissions/${cik}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error("Failed to fetch submissions JSON");
    return await res.json();
  }

  async function fetchLatestFilingCIK(cik) {
    if (!submissionsData) submissionsData = await fetchSubmissions(cik);
    for (let i = 0; i < submissionsData.filings.recent.form.length; i++) {
      const form = submissionsData.filings.recent.form[i];
      if (form === '10-K' || form === '10-Q') {
        return {
          accessionNumber: submissionsData.filings.recent.accessionNumber[i],
          reportDate: submissionsData.filings.recent.reportDate[i]
        };
      }
    }
    throw new Error("No recent 10-K/10-Q filing");
  }

  async function fetchXBRL(cik, tag) {
    const url = `/api/concept/${cik}/${tag}`;
    const res = await fetch(url);
    if (!res.ok) return { val: 0, end: '' };
    const data = await res.json();
    // Prefer USD units, fallback to first available
    const usd = data.units?.USD;
    if (usd && usd.length) return usd.slice(-1)[0];
    const anyUnit = Object.values(data.units || {})[0];
    return anyUnit && anyUnit.length ? anyUnit.slice(-1)[0] : { val: 0, end: '' };
  }

  async function fetchFinancials() {
    const ticker = document.getElementById("ticker").value.trim().toUpperCase();
    if (!ticker) {
      alert("Please enter a ticker symbol");
      return;
    }
    document.getElementById("status").textContent = "Fetching financial data...";
    balanceData = []; plData = []; ratioData = [];
    submissionsData = null;
    currentCIK = "";
    financialsForValuation = {};

    try {
      currentCIK = await fetchCIK(ticker);
      submissionsData = await fetchSubmissions(currentCIK);
      const filing = await fetchLatestFilingCIK(currentCIK);

      // Fetch required XBRL items:
      const [
        assets,
        currentAssets,
        liabilities,
        currentLiabilities,
        totalEquity,
        accountsPayable,
        accountsReceivable,
        accumulatedOCI,
        cashAndEquivalents,
        costOfGoodsSold,
        debtCurrent,
        debtLongTerm,
        depreciationAmortization,
        epsBasic,
        ebit,
        ebitda,
        grossMargin,
        grossProfit,
        incomeBeforeTax,
        interestExpense,
        inventory,
        netCashFromOps,
        netCashUsedInvesting,
        netIncomeLoss,
        operatingExpenses,
        operatingIncome,
        operatingMargin,
        ppeNet,
        retainedEarnings,
        revenue,
        returnOnAssets,
        returnOnEquity,
        totalAssets,
        totalCurrentAssets,
        totalCurrentLiabilities,
        totalLiabilities,
        totalLiabilitiesAndEquity,
        treasuryStock,
        sharesOutstandingData
      ] = await Promise.all([
        fetchXBRL(currentCIK, "Assets"),
        fetchXBRL(currentCIK, "AssetsCurrent"),
        fetchXBRL(currentCIK, "Liabilities"),
        fetchXBRL(currentCIK, "LiabilitiesCurrent"),
        fetchXBRL(currentCIK, "StockholdersEquity"),
        fetchXBRL(currentCIK, "AccountsPayable"),
        fetchXBRL(currentCIK, "AccountsReceivable"),
        fetchXBRL(currentCIK, "AccumulatedOtherComprehensiveIncomeLoss"),
        fetchXBRL(currentCIK, "CashAndCashEquivalents"),
        fetchXBRL(currentCIK, "CostOfGoodsSold"),
        fetchXBRL(currentCIK, "DebtCurrent"),
        fetchXBRL(currentCIK, "LongTermDebtNoncurrent"),
        fetchXBRL(currentCIK, "DepreciationAndAmortization"),
        fetchXBRL(currentCIK, "EarningsPerShareBasic"),
        fetchXBRL(currentCIK, "Ebit"),
        fetchXBRL(currentCIK, "Ebitda"),
        fetchXBRL(currentCIK, "GrossMargin"),
        fetchXBRL(currentCIK, "GrossProfit"),
        fetchXBRL(currentCIK, "IncomeBeforeTax"),
        fetchXBRL(currentCIK, "InterestExpense"),
        fetchXBRL(currentCIK, "Inventory"),
        fetchXBRL(currentCIK, "NetCashProvidedByOperatingActivities"),
        fetchXBRL(currentCIK, "NetCashUsedForInvestingActivities"),
        fetchXBRL(currentCIK, "NetIncomeLoss"),
        fetchXBRL(currentCIK, "OperatingExpenses"),
        fetchXBRL(currentCIK, "OperatingIncome"),
        fetchXBRL(currentCIK, "OperatingMargin"),
        fetchXBRL(currentCIK, "PropertyPlantAndEquipmentNet"),
        fetchXBRL(currentCIK, "RetainedEarnings"),
        fetchXBRL(currentCIK, "Revenues"),
        fetchXBRL(currentCIK, "ReturnOnAssets"),
        fetchXBRL(currentCIK, "ReturnOnEquity"),
        fetchXBRL(currentCIK, "TotalAssets"),
        fetchXBRL(currentCIK, "TotalCurrentAssets"),
        fetchXBRL(currentCIK, "TotalCurrentLiabilities"),
        fetchXBRL(currentCIK, "TotalLiabilities"),
        fetchXBRL(currentCIK, "TotalLiabilitiesAndEquity"),
        fetchXBRL(currentCIK, "TreasuryStock"),
        fetchXBRL(currentCIK, "CommonStockSharesOutstanding")
      ]);

      balanceData = [
        ["Label", "Date", "Value (USD)"],
        ["Total Assets", assets.end, assets.val],
        ["Current Assets", currentAssets.end, currentAssets.val],
        ["Total Liabilities", liabilities.end, liabilities.val],
        ["Current Liabilities", currentLiabilities.end, currentLiabilities.val],
        ["Total Equity", totalEquity.end, totalEquity.val],
        ["Accounts Payable", accountsPayable.end, accountsPayable.val],
        ["Accounts Receivable", accountsReceivable.end, accountsReceivable.val],
        ["Accumulated OCI", accumulatedOCI.end, accumulatedOCI.val],
        ["Cash & Cash Equivalents", cashAndEquivalents.end, cashAndEquivalents.val],
        ["Inventory", inventory.end, inventory.val],
        ["Property, Plant & Equipment", ppeNet.end, ppeNet.val],
        ["Short Term Debt", debtCurrent.end, debtCurrent.val],
        ["Long Term Debt", debtLongTerm.end, debtLongTerm.val],
        ["Treasury Stock", treasuryStock.end, treasuryStock.val]
      ];

      plData = [
        ["Label", "Date", "Value (USD)"],
        ["Revenue", revenue.end, revenue.val],
        ["Cost of Goods Sold", costOfGoodsSold.end, costOfGoodsSold.val],
        ["Gross Profit", grossProfit.end, grossProfit.val],
        ["Gross Margin", grossMargin.end, grossMargin.val],
        ["Operating Income", operatingIncome.end, operatingIncome.val],
        ["Operating Margin", operatingMargin.end, operatingMargin.val],
        ["EBIT", ebit.end, ebit.val],
        ["EBITDA", ebitda.end, ebitda.val],
        ["Interest Expense", interestExpense.end, interestExpense.val],
        ["Operating Expenses", operatingExpenses.end, operatingExpenses.val],
        ["Income Before Tax", incomeBeforeTax.end, incomeBeforeTax.val],
        ["Net Income", netIncomeLoss.end, netIncomeLoss.val],
        ["Depreciation & Amortization", depreciationAmortization.end, depreciationAmortization.val],
        ["EPS Basic", epsBasic.end, epsBasic.val],
        ["Return on Assets", returnOnAssets.end, returnOnAssets.val],
        ["Return on Equity", returnOnEquity.end, returnOnEquity.val],
        ["Net Cash Provided By Operating Activities", netCashFromOps.end, netCashFromOps.val],
        ["Net Cash Used For Investing Activities", netCashUsedInvesting.end, netCashUsedInvesting.val],
        ["Retained Earnings", retainedEarnings.end, retainedEarnings.val]
      ];

      renderTable("balanceSheetTable", balanceData);
      renderTable("plTable", plData);
      document.getElementById("status").textContent = `Data for ${ticker} as of ${assets.end}`;

      // Store key financials for valuation prompts later
      financialsForValuation = {
        dividends: parseFloat(prompt("Enter last annual dividend per share (e.g., 0.12):", "0.12")) || 0,
        growthRate: parseFloat(prompt("Enter expected dividend growth rate (e.g. 0.05):", "0.05")) || 0.05,
        wacc: parseFloat(prompt("Enter WACC (weighted average cost of capital):", "0.08")) || 0.08,
        fcf: parseFloat(prompt("Enter Free Cash Flow to Firm (FCF):", "0")) || 0,
        totalDebt: (debtLongTerm.val || 0) + (debtCurrent.val || 0),
        netIncome: netIncomeLoss.val || 0,
        bookValue: totalEquity.val || 0,
        roe: totalEquity.val ? (netIncomeLoss.val / totalEquity.val) : 0,
        sharesOutstanding: sharesOutstandingData.val || 0,
        peRatio: 0,
        ebit: ebit.val || 0,
        ebitda: ebitda.val || 0,
        da: depreciationAmortization.val || 0,
        cfo: netCashFromOps.val || 0,
        revenue: revenue.val || 0,
        currentAssets: currentAssets.val || 0,
        currentLiabilities: currentLiabilities.val || 0,
        interestExpense: interestExpense.val || 0,
        incomeBeforeTax: incomeBeforeTax.val || 0,
        cashAndEquivalents: cashAndEquivalents.val || 0
      };

      // Clear previous outputs
      document.getElementById("companyDetails").textContent = "";
      document.getElementById("dividendInfo").textContent = "";
      document.getElementById("ratiosTable").innerHTML = "";
      document.getElementById("valuationOutput").textContent = "";

    } catch (e) {
      document.getElementById("status").textContent = "Error: " + e.message;
      console.error(e);
    }
  }

  function renderTable(elementId, data) {
    const table = document.getElementById(elementId);
    if (!data.length) {
      table.innerHTML = "<tr><td>No data</td></tr>";
      return;
    }
    let html = "<tr>";
    for (let i = 0; i < data[0].length; i++) {
      html += `<th>${data[0][i]}</th>`;
    }
    html += "</tr>";
    for (let i = 1; i < data.length; i++) {
      html += "<tr>";
      for (let j = 0; j < data[i].length; j++) {
        html += `<td>${formatNumberIfNeeded(data[i][j])}</td>`;
      }
      html += "</tr>";
    }
    table.innerHTML = html;
  }

  function formatNumberIfNeeded(val) {
    if (typeof val === 'number') return val.toLocaleString();
    if (!isNaN(parseFloat(val)) && isFinite(val)) return parseFloat(val).toLocaleString();
    return val;
  }

  function calculateRatios() {
    if (!balanceData.length || !plData.length) {
      alert("Fetch financials first.");
      return;
    }

    const totalAssets = getVal("Total Assets", balanceData);
    const totalLiabilities = getVal("Total Liabilities", balanceData);
    const totalEquity = getVal("Total Equity", balanceData);
    const netIncome = getVal("Net Income", plData);
    const revenue = getVal("Revenue", plData);
    const currentAssets = getVal("Current Assets", balanceData);
    const currentLiabilities = getVal("Current Liabilities", balanceData);

    if (!totalAssets || !totalEquity || !revenue) {
      alert("Incomplete data for ratio calculations.");
      return;
    }

    ratioData = [
      ["Ratio", "Value"],
      ["Debt to Equity", (totalLiabilities / totalEquity).toFixed(2)],
      ["Return on Equity (ROE)", ((netIncome / totalEquity) * 100).toFixed(2) + "%"],
      ["Return on Assets (ROA)", ((netIncome / totalAssets) * 100).toFixed(2) + "%"],
      ["Net Profit Margin", ((netIncome / revenue) * 100).toFixed(2) + "%"],
      ["Current Ratio", (currentAssets / currentLiabilities).toFixed(2)]
    ];

    renderTable("ratiosTable", ratioData);
  }

  function calculateDetailedRatios() {
    if (!balanceData.length || !plData.length) {
      alert("Please fetch financial data first.");
      return;
    }

    const getValLocal = (label, data) => {
      const row = data.find(r => r[0] === label);
      return row ? parseFloat(row[2]) : 0;
    };

    const shortTermDebt = getValLocal("Short Term Debt", balanceData) || 0;
    const longTermDebt = getValLocal("Long Term Debt", balanceData) || 0;
    const totalDebt = shortTermDebt + longTermDebt;
    const equity = getValLocal("Total Equity", balanceData) || 0;
    const interestExpense = getValLocal("Interest Expense", plData) || 0;
    const netIncome = getValLocal("Net Income", plData) || 0;
    const revenue = getValLocal("Revenue", plData) || 0;
    const totalAssets = getValLocal("Total Assets", balanceData) || 0;

    const beta = parseFloat(prompt("Enter Beta value:", "0.73")) || 0.73;
    const riskFreeRate = parseFloat(prompt("Enter Risk-free rate (e.g., 0.0421):", "0.0421")) || 0.0421;
    const marketReturn = parseFloat(prompt("Enter Market Return (e.g., 0.1205):", "0.1205")) || 0.1205;
    const taxRate = parseFloat(prompt("Enter Tax rate (e.g., 0.168):", "0.168")) || 0.168;

    const costOfDebt = totalDebt > 0 ? interestExpense / totalDebt : 0;
    const costOfEquity = riskFreeRate + beta * (marketReturn - riskFreeRate);
    const debtToEquity = equity > 0 ? totalDebt / equity : 0;
    const roe = equity > 0 ? netIncome / equity : 0;
    const roa = totalAssets > 0 ? netIncome / totalAssets : 0;

    const equityWeight = equity / (equity + totalDebt);
    const debtWeight = 1 - equityWeight;
    const wacc = equityWeight * costOfEquity + debtWeight * costOfDebt * (1 - taxRate);

    const dividend = parseFloat(prompt("Enter last annual dividend per share:", "0.12")) || 0;
    const eps = parseFloat(prompt("Enter latest EPS:", "0.59")) || 0;
    const payoutRatio = eps > 0 ? dividend / eps : 0;

    const growthRate = roe * (1 - payoutRatio);

    ratioData = [
      ["Ratio", "Value"],
      ["Short Term Debt (USD)", shortTermDebt.toLocaleString()],
      ["Long Term Debt (USD)", longTermDebt.toLocaleString()],
      ["Total Debt (USD)", totalDebt.toLocaleString()],
      ["Equity (USD)", equity.toLocaleString()],
      ["Interest Expense (USD)", interestExpense.toLocaleString()],
      ["Cost of Debt (Interest/Total Debt)", costOfDebt.toFixed(4)],
      ["Cost of Equity (CAPM)", costOfEquity.toFixed(4)],
      ["Debt to Equity Ratio", debtToEquity.toFixed(4)],
      ["Return on Equity (ROE)", (roe * 100).toFixed(2) + "%"],
      ["Return on Assets (ROA)", (roa * 100).toFixed(2) + "%"],
      ["WACC", (wacc * 100).toFixed(2) + "%"],
      ["Payout Ratio", payoutRatio.toFixed(4)],
      ["Growth Rate", (growthRate * 100).toFixed(2) + "%"]
    ];

    renderTable("ratiosTable", ratioData);

    // Save some valuation data for later
    financialsForValuation = {
      dividends: dividend,
      growthRate: growthRate,
      wacc: wacc,
      fcf: parseFloat(prompt("Enter Free Cash Flow to Firm (FCF):", "0")) || 0,
      totalDebt: totalDebt,
      netIncome: netIncome,
      bookValue: equity,
      roe: roe,
      sharesOutstanding: parseFloat(prompt("Enter shares outstanding:", "1000000000")) || 1e9,
      peRatio: parseFloat(prompt("Enter current P/E ratio:", "15")) || 15,
      ebit: financialsForValuation.ebit,
      ebitda: financialsForValuation.ebitda,
      da: financialsForValuation.da,
      cfo: financialsForValuation.cfo,
      revenue: financialsForValuation.revenue,
      currentAssets: financialsForValuation.currentAssets,
      currentLiabilities: financialsForValuation.currentLiabilities,
      interestExpense: financialsForValuation.interestExpense,
      incomeBeforeTax: financialsForValuation.incomeBeforeTax
    };
  }

  function performEquityValuation() {
    if (!financialsForValuation.dividends || !financialsForValuation.wacc || !financialsForValuation.growthRate) {
      alert("Please calculate detailed ratios first to populate inputs.");
      return;
    }
    const d = financialsForValuation.dividends;
    const g = financialsForValuation.growthRate;
    const r = financialsForValuation.wacc;

    if (r <= g) {
      alert("WACC must be greater than growth rate for valuation.");
      return;
    }
    const valuation = d * (1 + g) / (r - g);
    document.getElementById("valuationOutput").textContent = `Simple Dividend Discount Model (DDM) Equity Valuation: $${valuation.toFixed(2)} per share`;
  }

  function runAdvancedValuation() {
    if (!financialsForValuation || Object.keys(financialsForValuation).length === 0) {
      alert("Please calculate detailed ratios first.");
      return;
    }
    const d = financialsForValuation.dividends;
    const g = financialsForValuation.growthRate;
    const r = financialsForValuation.wacc;
    const fcf = financialsForValuation.fcf;
    const totalDebt = financialsForValuation.totalDebt;
    const netIncome = financialsForValuation.netIncome;
    const bookValue = financialsForValuation.bookValue;
    const roe = financialsForValuation.roe;
    const sharesOutstanding = financialsForValuation.sharesOutstanding;
    const peRatio = financialsForValuation.peRatio;

    if (r <= g) {
      alert("WACC must be greater than growth rate for valuation.");
      return;
    }

    // Dividend Discount Model
    const ddmValue = d * (1 + g) / (r - g);

    // FCFF Valuation (Enterprise Value)
    const fcffValue = fcf * (1 + g) / (r - g);
    const equityValueFromFCFF = fcffValue - totalDebt;

    // Residual Income Model
    const residualIncome = (roe - r) * bookValue;
    const riValue = bookValue + residualIncome / r;

    // Relative Valuation
    const eps = sharesOutstanding > 0 ? (netIncome / sharesOutstanding) : 0;
    const relativeValuation = peRatio * eps;

    const output = `
CFA Advanced Equity Valuation:

Dividend Discount Model (DDM) Equity Value per share: $${ddmValue.toFixed(2)}
FCFF Valuation Equity Value (Firm - Debt): $${equityValueFromFCFF.toFixed(2)}
Residual Income Equity Value: $${riValue.toFixed(2)}
Relative Valuation (P/E * EPS): $${relativeValuation.toFixed(2)}
    `;
    document.getElementById("valuationOutput").textContent = output;
  }

  // Subramanyam-style Advanced FSA Valuation
  function runSubramanyamFSA() {
    const out = [];

    // Pull data
    const shares = Number(financialsForValuation.sharesOutstanding || 0);
    const ebit = Number(financialsForValuation.ebit || 0);
    const da = Number(financialsForValuation.da || 0);
    const cfo = Number(financialsForValuation.cfo || 0);
    const netIncome = Number(financialsForValuation.netIncome || 0);
    const totalDebt = Number(financialsForValuation.totalDebt || 0);
    const equityBV = Number(financialsForValuation.bookValue || 0);

    // Ask for missing/critical inputs
    const beta = parseFloat(prompt("Enter Beta (CAPM):", "0.9")) || 0.9;
    const rf = parseFloat(prompt("Enter Risk-free rate (dec):", "0.03")) || 0.03;
    const rm = parseFloat(prompt("Enter Market return (dec):", "0.10")) || 0.10;
    const taxRatePrompt = prompt("Enter effective tax rate (dec), leave blank to infer:", "");
    let taxRate = taxRatePrompt === "" ? null : parseFloat(taxRatePrompt);
    const capexProxy = parseFloat(prompt("Enter CapEx proxy (if unknown, use depreciation):", da.toString())) || da;
    const wcChange = parseFloat(prompt("Enter change in working capital (ΔWC, default 0):", "0")) || 0;

    const reasons = [];

    if (!shares || shares <= 0) reasons.push("Shares outstanding missing/invalid.");
    if (!equityBV || equityBV <= 0) reasons.push("Book value of equity missing/invalid.");
    // Infer tax rate if not provided: taxRate ≈ 1 - (Net Income / (Income Before Tax))
    if (taxRate == null) {
      const ibt = Number(financialsForValuation.incomeBeforeTax || 0);
      if (ibt > 0 && netIncome > 0) {
        taxRate = 1 - (netIncome / ibt);
      } else {
        reasons.push("Cannot infer tax rate (need Income Before Tax and Net Income).");
      }
    }
    if (taxRate != null && (taxRate < 0 || taxRate > 0.6)) reasons.push("Tax rate appears unreasonable (0–60% expected).");

    const ke = rf + beta * (rm - rf); // CAPM
    // Cost of debt
    const kd = Number(financialsForValuation.interestExpense || 0) > 0 && totalDebt > 0
      ? Number(financialsForValuation.interestExpense) / totalDebt
      : parseFloat(prompt("Enter pre-tax cost of debt (dec):", "0.04")) || 0.04;

    const mvEquityGuess = parseFloat(prompt("Enter current market value of equity (optional, 0 to skip):", "0")) || 0;
    const wd = totalDebt > 0 ? (mvEquityGuess > 0 ? (totalDebt / (mvEquityGuess + totalDebt)) : 0.5) : 0;
    const we = mvEquityGuess > 0 ? (mvEquityGuess / (mvEquityGuess + totalDebt)) : (1 - wd);
    const wacc = we * ke + wd * kd * (1 - (taxRate ?? 0.25));

    if (!isFinite(ke)) reasons.push("Cost of equity (CAPM) could not be computed.");
    if (!isFinite(wacc) || wacc <= 0) reasons.push("WACC invalid or non-positive.");
    if (reasons.length) {
      document.getElementById("valuationOutput").innerHTML = `⚠️ Conflicts:\n- ${reasons.join("\n- ")}`;
      return;
    }

    // FCFF using CFO-based approach (Subramanyam-style proxy):
    // FCFF ≈ CFO + (Interest Expense · (1−Tax)) − CapEx − ΔWC
    const interestExpense = Number(financialsForValuation.interestExpense || 0);
    const afterTaxInterest = interestExpense * (1 - taxRate);
    const fcff = cfo + afterTaxInterest - capexProxy - wcChange;

    // Single-stage terminal value
    const g = parseFloat(prompt("Enter long-run growth rate g (dec):", "0.03")) || 0.03;
    if (wacc <= g) {
      document.getElementById("valuationOutput").innerHTML = `⚠️ Conflict: WACC (${wacc.toFixed(4)}) must exceed growth (${g.toFixed(4)}).`;
      return;
    }
    const firmValueFCFF = fcff * (1 + g) / (wacc - g);
    const equityValue = firmValueFCFF - totalDebt;

    // Two-stage option (Subramanyam multi-stage): high growth for N years then terminal
    const useTwoStage = confirm("Use two-stage growth model? (OK=yes, Cancel=single-stage)");
    let equityValueTwoStage = null;
    if (useTwoStage) {
      const gHigh = parseFloat(prompt("Enter high growth rate (dec):", "0.08")) || 0.08;
      const yearsHigh = parseInt(prompt("Enter high growth period (years):", "5"), 10) || 5;
      const gStable = parseFloat(prompt("Enter stable growth rate (dec):", g.toString())) || g;
      if (wacc <= gStable) {
        document.getElementById("valuationOutput").innerHTML = `⚠️ Conflict: WACC (${wacc.toFixed(4)}) must exceed stable growth (${gStable.toFixed(4)}).`;
        return;
      }
      // FCFF path
      let pv = 0;
      for (let t = 1; t <= yearsHigh; t++) {
        const fcff_t = fcff * Math.pow(1 + gHigh, t);
        pv += fcff_t / Math.pow(1 + wacc, t);
      }
      const fcff_T = fcff * Math.pow(1 + gHigh, yearsHigh);
      const terminal = (fcff_T * (1 + gStable)) / (wacc - gStable);
      const pvTerminal = terminal / Math.pow(1 + wacc, yearsHigh + 1);
      const firmTwoStage = pv + pvTerminal;
      equityValueTwoStage = firmTwoStage - totalDebt;
    }

    // Implied per-share values
    const perShareEquity = shares > 0 ? (equityValue / shares) : 0;
    const perShareTwoStage = (equityValueTwoStage && shares > 0) ? (equityValueTwoStage / shares) : null;

    // Implied EPS consistency via residual income perspective
    // Residual Income (RI) = Net Income − (ke * Equity BV)
    // Equity value ≈ BV + RI / ke (single-period perpetuity assumption for illustration)
    const ri = netIncome - ke * equityBV;
    const riValue = equityBV + (ri / Math.max(ke, 1e-6));

    const basicEPS = Number(getVal("EPS Basic", plData) || 0);
    const impliedEPSFromNI = shares > 0 ? (netIncome / shares) : 0;

    const lines = [];
    lines.push(`Advanced FSA (Subramanyam-style) results:`);
    lines.push(`Cost of equity (CAPM) ke: ${ke.toFixed(4)}`);
    lines.push(`Cost of debt (pre-tax) kd: ${kd.toFixed(4)}`);
    lines.push(`Tax rate: ${taxRate.toFixed(4)}`);
    lines.push(`Weights (we/wd): ${we.toFixed(4)} / ${wd.toFixed(4)}`);
    lines.push(`WACC: ${wacc.toFixed(4)}`);
    lines.push(`FCFF (CFO + after-tax interest − CapEx − ΔWC): ${fcff.toLocaleString()}`);
    lines.push(`Growth g: ${g.toFixed(4)}`);
    lines.push(`Firm value (FCFF, single-stage): ${firmValueFCFF.toLocaleString()}`);
    lines.push(`Equity value (firm − debt): ${equityValue.toLocaleString()}`);
    lines.push(`Per-share equity value (single-stage): ${perShareEquity.toFixed(4)}`);

    if (useTwoStage && equityValueTwoStage != null) {
      lines.push(`Equity value (two-stage): ${equityValueTwoStage.toLocaleString()}`);
      lines.push(`Per-share equity value (two-stage): ${perShareTwoStage.toFixed(4)}`);
    }

    lines.push(`Residual Income (RI) = NI − ke·BV: ${ri.toLocaleString()}`);
    lines.push(`Residual Income model equity value: ${riValue.toLocaleString()}`);
    lines.push(`Basic EPS reported: ${basicEPS}`);
    lines.push(`EPS implied by Net Income & Shares: ${impliedEPSFromNI.toFixed(4)}`);

    document.getElementById("valuationOutput").textContent = lines.join("\n");
  }

  function getVal(label, data) {
    const row = data.find(r => r[0] === label);
    return row ? parseFloat(row[2]) : 0;
  }

  function showCompanyDetails() {
    if (!submissionsData) {
      alert("Fetch financials first");
      return;
    }
    const info = `
Company Name: ${submissionsData.entityName}
CIK: ${currentCIK}
SIC Code: ${submissionsData.sic}
State Location: ${submissionsData.stateOfInc}
Filing Count: ${submissionsData.filings.recent.form.length}
Most Recent Filing Date: ${submissionsData.filings.recent.reportDate[0]}
    `;
    document.getElementById("companyDetails").textContent = info;
  }

  function showLatestDividend() {
    if (!plData.length) {
      alert("Fetch financials first");
      return;
    }
    const eps = getVal("EPS Basic", plData);
    const dividend = financialsForValuation.dividends || 0;
    const payout = eps > 0 ? dividend / eps : 0;
    const info = `
Latest EPS (Basic): ${eps}
Last Annual Dividend per Share: ${dividend}
Payout Ratio: ${(payout * 100).toFixed(2)}%
    `;
    document.getElementById("dividendInfo").textContent = info;
  }

  function showAllStatementItems() {
    if (!submissionsData) {
      alert("Fetch financials first");
      return;
    }
    const items = submissionsData.filings.recent.form;
    alert("All recent statement items:\n" + items.join(", "));
  }

  function showStandardXBRLItems() {
    alert("XBRL standard items include Assets, Liabilities, Equity, Revenue, Net Income, EPS, CFO, PPE, Debt, etc.");
  }

  function downloadCSV() {
    if (!balanceData.length && !plData.length) {
      alert("Fetch financial data first");
      return;
    }
    let csv = "Section,Label,Date,Value (USD)\n";
    csv += balanceData.slice(1).map(r => ["Balance Sheet", ...r].join(",")).join("\n") + "\n";
    csv += plData.slice(1).map(r => ["Profit & Loss", ...r].join(",")).join("\n");

    const blob = new Blob([csv], {type: "text/csv"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "financials.csv";
    document.body.appendChild(a);
    a.click();
    a.remove();
  }
</script>

</body>
</html>